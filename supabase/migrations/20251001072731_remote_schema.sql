create type "public"."address_type" as enum ('headquarters', 'office');

create type "public"."application_status" as enum ('accepted', 'rejected');

create type "public"."job_salary_type" as enum ('annual', 'hourly');

create type "public"."job_status" as enum ('open', 'filled', 'closed');

create type "public"."job_type" as enum ('full_time', 'part_time', 'contract', 'internship');

create type "public"."user_type" as enum ('company', 'job_seeker');

create table "public"."applications" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "job_id" bigint not null,
    "status" application_status,
    "reason" text,
    "user_id" uuid
);


alter table "public"."applications" enable row level security;

create table "public"."companies" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "name" text not null,
    "num_employees" integer not null,
    "industry_id" bigint not null,
    "description" text not null,
    "user_id" uuid,
    "contact_email" text,
    "interview_process" jsonb
);


alter table "public"."companies" enable row level security;

create table "public"."company_addresses" (
    "id" bigint generated by default as identity not null,
    "street" text not null,
    "city" text not null,
    "state" text not null,
    "zip" text not null,
    "company_id" bigint not null,
    "type" address_type not null,
    "street_2" text,
    "phone" text
);


alter table "public"."company_addresses" enable row level security;

create table "public"."company_tech_stacks" (
    "company_id" bigint not null,
    "skill_version_id" bigint not null
);


alter table "public"."company_tech_stacks" enable row level security;

create table "public"."industries" (
    "id" bigint generated by default as identity not null,
    "name" character varying not null
);


alter table "public"."industries" enable row level security;

create table "public"."interview_rounds" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "interview_id" bigint not null,
    "round" interview_round not null,
    "status" text
);


alter table "public"."interview_rounds" enable row level security;

create table "public"."interviews" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "application_id" bigint not null,
    "status" text
);


alter table "public"."interviews" enable row level security;

create table "public"."job_roles" (
    "job_id" bigint not null,
    "role_id" bigint not null,
    "percent" percent not null,
    "role_level" role_level not null default NULL::integer
);


alter table "public"."job_roles" enable row level security;

create table "public"."job_skill_versions" (
    "job_id" bigint not null,
    "skill_version_id" bigint not null
);


alter table "public"."job_skill_versions" enable row level security;

create table "public"."job_skills" (
    "job_id" bigint not null,
    "skill_id" bigint not null
);


alter table "public"."job_skills" enable row level security;

create table "public"."jobs" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "company_id" bigint not null,
    "title" text not null,
    "status" job_status not null default 'open'::job_status,
    "description" text,
    "salary_low" bigint not null,
    "salary_high" bigint not null,
    "updated_at" timestamp with time zone not null default now(),
    "type" job_type not null default 'full_time'::job_type,
    "salary_type" job_salary_type not null default 'annual'::job_salary_type,
    "company_address_id" bigint
);


alter table "public"."jobs" enable row level security;

create table "public"."roles" (
    "id" bigint generated by default as identity not null,
    "name" text not null,
    "description" text,
    "reference" text
);


alter table "public"."roles" enable row level security;

create table "public"."skill_categories" (
    "id" bigint generated by default as identity not null,
    "name" text not null,
    "parent_skill_category_id" bigint,
    "description" text,
    "reference" text,
    "notes" text
);


alter table "public"."skill_categories" enable row level security;

create table "public"."skill_relations" (
    "skill_id" bigint not null,
    "related_skill_id" bigint not null,
    "is_bidirectional" boolean not null default false
);


alter table "public"."skill_relations" enable row level security;

create table "public"."skill_versions" (
    "id" bigint generated by default as identity not null,
    "skill_id" bigint not null,
    "version" text not null,
    "reference" text,
    "notes" text,
    "release_date" date not null,
    "ordinal" integer not null
);


alter table "public"."skill_versions" enable row level security;

create table "public"."skills" (
    "id" bigint generated by default as identity not null,
    "name" text not null,
    "description" text,
    "skill_category_id" bigint not null,
    "abbreviation" text,
    "reference" text,
    "notes" text
);


alter table "public"."skills" enable row level security;

CREATE UNIQUE INDEX addresses_pkey ON public.company_addresses USING btree (id);

CREATE UNIQUE INDEX companies_pkey ON public.companies USING btree (id);

CREATE UNIQUE INDEX companies_user_id_key ON public.companies USING btree (user_id);

CREATE UNIQUE INDEX industries_name_key ON public.industries USING btree (name);

CREATE UNIQUE INDEX industries_pkey ON public.industries USING btree (id);

CREATE UNIQUE INDEX interview_round ON public.interview_rounds USING btree (interview_id, round);

CREATE UNIQUE INDEX interview_rounds_pkey ON public.interview_rounds USING btree (id);

CREATE UNIQUE INDEX interviews_application_id_key ON public.interviews USING btree (application_id);

CREATE UNIQUE INDEX interviews_pkey ON public.interviews USING btree (id);

CREATE UNIQUE INDEX job_applications_pkey ON public.applications USING btree (id);

CREATE UNIQUE INDEX job_roles_pkey ON public.job_roles USING btree (job_id, role_id);

CREATE UNIQUE INDEX job_skill ON public.job_skills USING btree (job_id, skill_id);

CREATE UNIQUE INDEX job_skill_version ON public.job_skill_versions USING btree (job_id, skill_version_id);

CREATE UNIQUE INDEX job_skill_versions_pkey ON public.job_skill_versions USING btree (job_id, skill_version_id);

CREATE UNIQUE INDEX job_skills_pkey ON public.job_skills USING btree (job_id, skill_id);

CREATE UNIQUE INDEX jobs2_pkey ON public.jobs USING btree (id);

CREATE UNIQUE INDEX skill_relations_pkey ON public.skill_relations USING btree (skill_id, related_skill_id);

CREATE UNIQUE INDEX skill_types_pkey ON public.skill_categories USING btree (id);

CREATE UNIQUE INDEX skill_version_ordinal ON public.skill_versions USING btree (skill_id, ordinal);

CREATE UNIQUE INDEX skill_versions_pkey ON public.skill_versions USING btree (id);

CREATE UNIQUE INDEX skills_pkey ON public.skills USING btree (id);

CREATE UNIQUE INDEX tech_stacks_pkey ON public.company_tech_stacks USING btree (company_id, skill_version_id);

CREATE UNIQUE INDEX titles_pkey ON public.roles USING btree (id);

CREATE UNIQUE INDEX titles_title_key ON public.roles USING btree (name);

CREATE UNIQUE INDEX unique_headquarters ON public.company_addresses USING btree (company_id, type) WHERE (type = 'headquarters'::address_type);

alter table "public"."applications" add constraint "job_applications_pkey" PRIMARY KEY using index "job_applications_pkey";

alter table "public"."companies" add constraint "companies_pkey" PRIMARY KEY using index "companies_pkey";

alter table "public"."company_addresses" add constraint "addresses_pkey" PRIMARY KEY using index "addresses_pkey";

alter table "public"."company_tech_stacks" add constraint "tech_stacks_pkey" PRIMARY KEY using index "tech_stacks_pkey";

alter table "public"."industries" add constraint "industries_pkey" PRIMARY KEY using index "industries_pkey";

alter table "public"."interview_rounds" add constraint "interview_rounds_pkey" PRIMARY KEY using index "interview_rounds_pkey";

alter table "public"."interviews" add constraint "interviews_pkey" PRIMARY KEY using index "interviews_pkey";

alter table "public"."job_roles" add constraint "job_roles_pkey" PRIMARY KEY using index "job_roles_pkey";

alter table "public"."job_skill_versions" add constraint "job_skill_versions_pkey" PRIMARY KEY using index "job_skill_versions_pkey";

alter table "public"."job_skills" add constraint "job_skills_pkey" PRIMARY KEY using index "job_skills_pkey";

alter table "public"."jobs" add constraint "jobs2_pkey" PRIMARY KEY using index "jobs2_pkey";

alter table "public"."roles" add constraint "titles_pkey" PRIMARY KEY using index "titles_pkey";

alter table "public"."skill_categories" add constraint "skill_types_pkey" PRIMARY KEY using index "skill_types_pkey";

alter table "public"."skill_relations" add constraint "skill_relations_pkey" PRIMARY KEY using index "skill_relations_pkey";

alter table "public"."skill_versions" add constraint "skill_versions_pkey" PRIMARY KEY using index "skill_versions_pkey";

alter table "public"."skills" add constraint "skills_pkey" PRIMARY KEY using index "skills_pkey";

alter table "public"."applications" add constraint "applications_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."applications" validate constraint "applications_user_id_fkey";

alter table "public"."applications" add constraint "job_applications_job_id_fkey" FOREIGN KEY (job_id) REFERENCES jobs(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."applications" validate constraint "job_applications_job_id_fkey";

alter table "public"."companies" add constraint "companies_industry_id_fkey" FOREIGN KEY (industry_id) REFERENCES industries(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."companies" validate constraint "companies_industry_id_fkey";

alter table "public"."companies" add constraint "companies_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."companies" validate constraint "companies_user_id_fkey";

alter table "public"."companies" add constraint "companies_user_id_key" UNIQUE using index "companies_user_id_key";

alter table "public"."company_addresses" add constraint "addresses_company_id_fkey" FOREIGN KEY (company_id) REFERENCES companies(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."company_addresses" validate constraint "addresses_company_id_fkey";

alter table "public"."company_tech_stacks" add constraint "tech_stacks_company_id_fkey" FOREIGN KEY (company_id) REFERENCES companies(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."company_tech_stacks" validate constraint "tech_stacks_company_id_fkey";

alter table "public"."company_tech_stacks" add constraint "tech_stacks_skill_version_id_fkey" FOREIGN KEY (skill_version_id) REFERENCES skill_versions(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."company_tech_stacks" validate constraint "tech_stacks_skill_version_id_fkey";

alter table "public"."industries" add constraint "industries_name_key" UNIQUE using index "industries_name_key";

alter table "public"."interview_rounds" add constraint "interview_rounds_interview_id_fkey" FOREIGN KEY (interview_id) REFERENCES interviews(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."interview_rounds" validate constraint "interview_rounds_interview_id_fkey";

alter table "public"."interviews" add constraint "interviews_application_id_fkey" FOREIGN KEY (application_id) REFERENCES applications(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."interviews" validate constraint "interviews_application_id_fkey";

alter table "public"."interviews" add constraint "interviews_application_id_key" UNIQUE using index "interviews_application_id_key";

alter table "public"."job_roles" add constraint "job_roles_job_id_fkey" FOREIGN KEY (job_id) REFERENCES jobs(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."job_roles" validate constraint "job_roles_job_id_fkey";

alter table "public"."job_roles" add constraint "job_roles_role_id_fkey" FOREIGN KEY (role_id) REFERENCES roles(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."job_roles" validate constraint "job_roles_role_id_fkey";

alter table "public"."job_skill_versions" add constraint "job_skill_versions_job_id_fkey" FOREIGN KEY (job_id) REFERENCES jobs(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."job_skill_versions" validate constraint "job_skill_versions_job_id_fkey";

alter table "public"."job_skill_versions" add constraint "job_skill_versions_skill_version_id_fkey" FOREIGN KEY (skill_version_id) REFERENCES skill_versions(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."job_skill_versions" validate constraint "job_skill_versions_skill_version_id_fkey";

alter table "public"."job_skills" add constraint "job_skills_job_id_fkey" FOREIGN KEY (job_id) REFERENCES jobs(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."job_skills" validate constraint "job_skills_job_id_fkey";

alter table "public"."job_skills" add constraint "job_skills_skill_id_fkey" FOREIGN KEY (skill_id) REFERENCES skills(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."job_skills" validate constraint "job_skills_skill_id_fkey";

alter table "public"."jobs" add constraint "jobs_company_id_fkey" FOREIGN KEY (company_id) REFERENCES companies(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."jobs" validate constraint "jobs_company_id_fkey";

alter table "public"."jobs" add constraint "jobs_location_fkey" FOREIGN KEY (company_address_id) REFERENCES company_addresses(id) ON UPDATE CASCADE ON DELETE SET NULL not valid;

alter table "public"."jobs" validate constraint "jobs_location_fkey";

alter table "public"."jobs" add constraint "salary_check" CHECK (((salary_low)::integer <= (salary_high)::integer)) not valid;

alter table "public"."jobs" validate constraint "salary_check";

alter table "public"."jobs" add constraint "salary_check_type" CHECK ((((salary_type = 'annual'::job_salary_type) AND (salary_low >= 10000) AND (salary_high <= 200000)) OR ((salary_type = 'hourly'::job_salary_type) AND (salary_low >= 20) AND (salary_high <= 200)))) not valid;

alter table "public"."jobs" validate constraint "salary_check_type";

alter table "public"."roles" add constraint "titles_title_key" UNIQUE using index "titles_title_key";

alter table "public"."skill_categories" add constraint "skill_categories_parent_skill_category_id_fkey" FOREIGN KEY (parent_skill_category_id) REFERENCES skill_categories(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."skill_categories" validate constraint "skill_categories_parent_skill_category_id_fkey";

alter table "public"."skill_relations" add constraint "skill_relations_related_skill_id_fkey" FOREIGN KEY (related_skill_id) REFERENCES skills(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."skill_relations" validate constraint "skill_relations_related_skill_id_fkey";

alter table "public"."skill_relations" add constraint "skill_relations_skill_id_fkey" FOREIGN KEY (skill_id) REFERENCES skills(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."skill_relations" validate constraint "skill_relations_skill_id_fkey";

alter table "public"."skill_versions" add constraint "skill_versions_skill_id_fkey" FOREIGN KEY (skill_id) REFERENCES skills(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."skill_versions" validate constraint "skill_versions_skill_id_fkey";

alter table "public"."skills" add constraint "skills_skill_category_id_fkey" FOREIGN KEY (skill_category_id) REFERENCES skill_categories(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."skills" validate constraint "skills_skill_category_id_fkey";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.foo()
 RETURNS void
 LANGUAGE plpgsql
AS $function$BEGIN
  FOR i IN 1..100 LOOP
    update company_addresses set type = 'headquarters' where id = round(random() * 2000) + 1;
  END LOOP;
  RETURN;
END;$function$
;

create policy "Job applications are visible to everyone."
on "public"."applications"
as permissive
for select
to authenticated
using (true);


create policy "Companies are editable only by their users"
on "public"."companies"
as permissive
for update
to authenticated
using ((( SELECT auth.uid() AS uid) = user_id));


create policy "Companies are visible to themselves or to job seekers"
on "public"."companies"
as permissive
for select
to authenticated
using (((( SELECT auth.uid() AS uid) = user_id) OR (( SELECT ((auth.jwt() -> 'user_metadata'::text) ->> 'type'::text)) = 'job_seeker'::text)));


create policy "Enable insert for authenticated users only"
on "public"."companies"
as permissive
for insert
to authenticated
with check ((( SELECT auth.uid() AS uid) = user_id));


create policy "Addresses are visible to everyone."
on "public"."company_addresses"
as permissive
for select
to authenticated
using (true);


create policy "Addresses can only be added by their companies"
on "public"."company_addresses"
as permissive
for insert
to authenticated
with check ((( SELECT auth.uid() AS uid) IN ( SELECT companies.user_id
   FROM companies
  WHERE (companies.id = company_addresses.company_id))));


create policy "Addresses can only be deleted by their companies"
on "public"."company_addresses"
as permissive
for delete
to authenticated
using ((( SELECT auth.uid() AS uid) IN ( SELECT companies.user_id
   FROM companies
  WHERE (companies.id = company_addresses.company_id))));


create policy "Addresses can only be updated by their companies"
on "public"."company_addresses"
as permissive
for update
to authenticated
using ((( SELECT auth.uid() AS uid) IN ( SELECT companies.user_id
   FROM companies
  WHERE (companies.id = company_addresses.company_id))));


create policy "Tech stacks are visible to everyone."
on "public"."company_tech_stacks"
as permissive
for select
to authenticated
using (true);


create policy "Enable read access for all users"
on "public"."industries"
as permissive
for select
to authenticated
using (true);


create policy "Job interview rounds are visible to everyone."
on "public"."interview_rounds"
as permissive
for select
to authenticated
using (true);


create policy "Job interviews are visible to everyone."
on "public"."interviews"
as permissive
for select
to anon
using (true);


create policy "Job roles are creatable by their companies"
on "public"."job_roles"
as permissive
for insert
to authenticated
with check ((( SELECT auth.uid() AS uid) IN ( SELECT companies.user_id
   FROM companies
  WHERE (companies.id IN ( SELECT jobs.company_id
           FROM jobs
          WHERE (jobs.id = job_roles.job_id))))));


create policy "Job roles are deletable by their companies"
on "public"."job_roles"
as permissive
for delete
to public
using ((( SELECT auth.uid() AS uid) IN ( SELECT companies.user_id
   FROM companies
  WHERE (companies.id IN ( SELECT jobs.company_id
           FROM jobs
          WHERE (jobs.id = job_roles.job_id))))));


create policy "Job roles are editable by their companies"
on "public"."job_roles"
as permissive
for update
to authenticated
using ((( SELECT auth.uid() AS uid) IN ( SELECT companies.user_id
   FROM companies
  WHERE (companies.id IN ( SELECT jobs.company_id
           FROM jobs
          WHERE (jobs.id = job_roles.job_id))))));


create policy "Job roles are visible to their companies or to job seekers"
on "public"."job_roles"
as permissive
for select
to authenticated
using (((( SELECT auth.uid() AS uid) IN ( SELECT companies.user_id
   FROM companies
  WHERE (companies.id IN ( SELECT jobs.company_id
           FROM jobs
          WHERE (jobs.id = job_roles.job_id))))) OR (( SELECT ((auth.jwt() -> 'user_metadata'::text) ->> 'type'::text) AS type) = 'job_seeker'::text)));


create policy "Job skill versions are visible to everyone."
on "public"."job_skill_versions"
as permissive
for select
to anon
using (true);


create policy "Job skills are creatable by their companies"
on "public"."job_skills"
as permissive
for insert
to authenticated
with check ((( SELECT auth.uid() AS uid) IN ( SELECT companies.user_id
   FROM companies
  WHERE (companies.id IN ( SELECT jobs.company_id
           FROM jobs
          WHERE (jobs.id = job_skills.job_id))))));


create policy "Job skills are deletable by their companies"
on "public"."job_skills"
as permissive
for delete
to authenticated
using ((( SELECT auth.uid() AS uid) IN ( SELECT companies.user_id
   FROM companies
  WHERE (companies.id IN ( SELECT jobs.company_id
           FROM jobs
          WHERE (jobs.id = job_skills.job_id))))));


create policy "Job skills are editable by their companies"
on "public"."job_skills"
as permissive
for update
to authenticated
using ((( SELECT auth.uid() AS uid) IN ( SELECT companies.user_id
   FROM companies
  WHERE (companies.id IN ( SELECT jobs.company_id
           FROM jobs
          WHERE (jobs.id = job_skills.job_id))))));


create policy "Job skills are visible to their companies or to job seekers"
on "public"."job_skills"
as permissive
for select
to authenticated
using (((( SELECT auth.uid() AS uid) IN ( SELECT companies.user_id
   FROM companies
  WHERE (companies.id IN ( SELECT jobs.company_id
           FROM jobs
          WHERE (jobs.id = job_skills.job_id))))) OR (( SELECT ((auth.jwt() -> 'user_metadata'::text) ->> 'type'::text) AS type) = 'job_seeker'::text)));


create policy "Jobs are creatable by their companies"
on "public"."jobs"
as permissive
for insert
to public
with check ((( SELECT auth.uid() AS uid) IN ( SELECT companies.user_id
   FROM companies
  WHERE (companies.id = jobs.company_id))));


create policy "Jobs are deletable by their companies"
on "public"."jobs"
as permissive
for delete
to public
using ((( SELECT auth.uid() AS uid) IN ( SELECT companies.user_id
   FROM companies
  WHERE (companies.id = jobs.company_id))));


create policy "Jobs are editable by their companies"
on "public"."jobs"
as permissive
for update
to public
using ((( SELECT auth.uid() AS uid) IN ( SELECT companies.user_id
   FROM companies
  WHERE (companies.id = jobs.company_id))));


create policy "Jobs are visible to their companies or to job seekers"
on "public"."jobs"
as permissive
for select
to authenticated
using (((( SELECT auth.uid() AS uid) IN ( SELECT companies.user_id
   FROM companies
  WHERE (companies.id = jobs.company_id))) OR (( SELECT ((auth.jwt() -> 'user_metadata'::text) ->> 'type'::text) AS type) = 'job_seeker'::text)));


create policy "Roles are visible to everyone."
on "public"."roles"
as permissive
for select
to authenticated, anon
using (true);


create policy "Skill categories are visible to everyone."
on "public"."skill_categories"
as permissive
for select
to authenticated
using (true);


create policy "Skill relations are visible to everyone."
on "public"."skill_relations"
as permissive
for select
to anon
using (true);


create policy "Skill versions are visible to everyone."
on "public"."skill_versions"
as permissive
for select
to authenticated
using (true);


create policy "Skills are visible to everyone."
on "public"."skills"
as permissive
for select
to authenticated
using (true);




